<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<title>Curso de C</title>
<meta NAME="Template" CONTENT="C:\ARQUIVOS DE PROGRAMAS\MICROSOFT OFFICE\OFFICE\html.dot">
</head>

<body TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff" ALINK="#FF0000">

<h2 ALIGN="CENTER">Curso de C</h2>

<p ALIGN="CENTER"><img SRC="line.gif" WIDTH="485" HEIGHT="8"></p>

<h3 align="center">Abrindo e Fechando um Arquivo</h3>

<ul>
  <li><a HREF="#c951">fopen</a> </li>
  <li><a HREF="#c952">exit</a> </li>
  <li><a HREF="#c953">fclose</a> </li>
</ul>

<hr>

<p>O sistema de entrada e saída do ANSI C é composto por uma série de funções, cujos
protótipos estão reunidos em <strong>stdio.h</strong> . Todas estas funções trabalham
com o conceito de &quot;ponteiro de arquivo&quot;. Este não é um tipo propriamente dito,
mas uma definição usando o comando <a HREF="cb60.html">typedef</a>. Esta definição
também está no arquivo <b>stdio.h</b>. Podemos declarar um ponteiro de arquivo da
seguinte maneira: </p>

<pre>FILE *p;</pre>
<b>

<p>p</b> será então um ponteiro para um arquivo. É usando este tipo de ponteiro que
vamos poder manipular arquivos no C. </p>

<h4><a NAME="c951"></a>fopen</h4>

<p>Esta é a função de abertura de arquivos. Seu protótipo é: </p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fopen (char *nome_do_arquivo,char *modo);</pre>

<p>O nome_do_arquivo determina qual arquivo deverá ser aberto. Este nome deve ser válido
no sistema operacional que estiver sendo utilizado. O modo de abertura diz à função <b>fopen()</b>
que tipo de uso você vai fazer do arquivo. A tabela abaixo mostra os valores de modo
válidos: <br>
&nbsp; </p>
<div align="center"><center>

<table BORDER="1" CELLSPACING="1">
  <tr>
    <td VALIGN="MIDDLE"><p ALIGN="CENTER"><b>Modo</b></td>
    <td VALIGN="MIDDLE"><b><p ALIGN="CENTER">Significado</b></td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;r&quot;</td>
    <td VALIGN="MIDDLE">Abre um arquivo texto para leitura. O arquivo deve existir antes de
    ser aberto.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;w&quot;</td>
    <td VALIGN="MIDDLE">Abrir um arquivo texto para gravação. Se o arquivo não existir, ele
    será criado. Se já existir, o conteúdo anterior será destruído. </td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;a&quot;</td>
    <td VALIGN="MIDDLE">Abrir um arquivo texto para gravação. Os dados serão adicionados no
    fim do arquivo (&quot;append&quot;), se ele já existir, ou um novo arquivo será criado,
    no caso de arquivo não existente anteriormente.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;rb&quot;</td>
    <td VALIGN="MIDDLE">Abre um arquivo binário para leitura. Igual ao modo &quot;r&quot;
    anterior, só que o arquivo é binário.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;wb&quot;</td>
    <td VALIGN="MIDDLE">Cria um arquivo binário para escrita, como no modo &quot;w&quot;
    anterior, só que o arquivo é binário.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;ab&quot;</td>
    <td VALIGN="MIDDLE">Acrescenta dados binários no fim do arquivo, como no modo
    &quot;a&quot; anterior, só que o arquivo é binário.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;r+&quot;</td>
    <td VALIGN="MIDDLE">Abre um arquivo texto para leitura e gravação. O arquivo deve
    existir e pode ser modificado.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;w+&quot;</td>
    <td VALIGN="MIDDLE">Cria um arquivo texto para leitura e gravação. Se o arquivo existir,
    o conteúdo anterior será destruído. Se não existir, será criado.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;a+&quot;</td>
    <td VALIGN="MIDDLE">Abre um arquivo texto para gravação e leitura. Os dados serão
    adicionados no fim do arquivo se ele já existir, ou um novo arquivo será criado, no caso
    de arquivo não existente anteriormente.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;r+b&quot;</td>
    <td VALIGN="MIDDLE">Abre um arquivo binário para leitura e escrita. O mesmo que
    &quot;r+&quot; acima, só que o arquivo é binário.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;w+b&quot;</td>
    <td VALIGN="MIDDLE">Cria um arquivo binário para leitura e escrita. O mesmo que
    &quot;w+&quot; acima, só que o arquivo é binário.</td>
  </tr>
  <tr>
    <td VALIGN="MIDDLE">&quot;a+b&quot;</td>
    <td VALIGN="MIDDLE">Acrescenta dados ou cria uma arquivo binário para leitura e escrita.
    O mesmo que &quot;a+&quot; acima, só que o arquivo é binário</td>
  </tr>
</table>
</center></div>

<p ALIGN="left">Poderíamos então, para abrir um arquivo binário para escrita, escrever:
</p>

<pre><small>FILE *fp;		/* Declaração da estrutura
fp=fopen (&quot;exemplo.bin&quot;,&quot;wb&quot;);  /* o arquivo se chama exemplo.bin e está localizado no diretório corrente */
if (!fp)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (&quot;Erro na abertura do arquivo.&quot;);</small></pre>

<p>A condição <b>!fp</b> testa se o arquivo foi aberto com sucesso porque no caso de um
erro a função <b>fopen()</b> retorna um ponteiro nullo (<b>NULL</b>).&nbsp; </p>

<p>Uma vez aberto um arquivo, vamos poder ler ou escrever nele utilizando as funções que
serão apresentadas nas próximas páginas.</p>

<p>Toda vez que estamos trabalhando com arquivos, há uma espécie de posição atual no
arquivo. Esta&nbsp; é a posição de onde será lido ou escrito o próximo caractere.
Normalmente, num acesso sequencial a um arquivo, não temos que mexer nesta posição pois
quando lemos um caractere a posição no arquivo é automaticamente atualizada. Num acesso
randômico teremos que mexer nesta posição (ver <a HREF="c970.html">fseek()</a>). </p>

<h4><a NAME="c952"></a>exit</h4>

<p>Aqui abrimos um parênteses para explicar a função <b>exit()</b> cujo protótipo é: </p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void exit (int codigo_de_retorno);</pre>

<p>Para utilizá-la deve-se colocar um include para o arquivo de cabeçalho stdlib.h. Esta
função aborta a execução do programa. Pode ser chamada de qualquer ponto no programa e
faz com que o programa termine e retorne, para o sistema operacional, o
código_de_retorno. A convenção mais usada é que um programa retorne zero no caso de um
término normal e retorne um número não nulo no caso de ter ocorrido um problema. A
função <b>exit()</b> se torna importante em casos como alocação dinâmica e abertura
de arquivos pois nestes casos, se o programa não conseguir a memória necessária ou
abrir o arquivo, a melhor saída pode ser terminar a execução do programa. Poderíamos
reescrever o exemplo da seção anterior usando agora o exit() para garantir que o
programa não deixará de abrir o arquivo: </p>

<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; /* Para a função exit() */
main (void)
{
FILE *fp;
...
fp=fopen (&quot;exemplo.bin&quot;,&quot;wb&quot;);
if (!fp)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (&quot;Erro na abertura do arquivo. Fim de programa.&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit (1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
...
return 0;
}</pre>

<h4><a NAME="c953"></a>fclose</h4>

<p>Quando acabamos de usar um arquivo que abrimos, devemos fechá-lo. Para tanto usa-se a
função <b>fclose()</b>: </p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int fclose (FILE *fp);</pre>

<p>O ponteiro <b>fp</b> passado à função <b>fclose()</b> determina o arquivo a ser
fechado. A função retorna zero no caso de sucesso. </p>

<p>Fechar um arquivo faz com que qualquer caracter que tenha permanecido no
&quot;buffer&quot; associado ao fluxo de saída seja gravado. Mas, o que é este
&quot;buffer&quot;? Quando você envia caracteres para serem gravados em um arquivo, estes
caracteres são armazenados temporariamente em uma área de memória (o
&quot;buffer&quot;) em vez de serem escritos em disco imediatamente. Quando o
&quot;buffer&quot; estiver cheio, seu conteúdo é escrito no disco de uma vez. A razão
para se fazer isto tem a ver com a eficiência nas leituras e gravações de arquivos. Se,
para cada caracter que fossemos gravar, tivéssemos que posicionar a cabeça de gravação
em um ponto específico do disco, apenas para gravar aquele caracter, as gravações
seriam muito lentas. Assim estas gravações só serão efetuadas quando houver um volume
razoável de informações a serem gravadas ou quando o arquivo for fechado.</p>

<p>A função <a href="#c952">exit()</a> fecha todos os arquivos que um programa tiver
aberto.</p>

<p ALIGN="CENTER"><a HREF="c940.html"><img SRC="left.gif" BORDER="0" WIDTH="36"
HEIGHT="34" ALT></a>&nbsp; <a HREF="c900.html"><img SRC="up.gif" BORDER="0" WIDTH="36"
HEIGHT="34" ALT></a>&nbsp; <a HREF="c960.html"><img SRC="right.gif" BORDER="0" WIDTH="36"
HEIGHT="34" ALT="P"></a></p>

<hr>

<p><small><font face="Arial">Curso de C da EE/UFMG - 1996 - 2000</font></small></p>
</body>
</html>
